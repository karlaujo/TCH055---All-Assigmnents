-- Question 1:
-- S'assurer que la date de fin de session est d'au moins 10 semaines

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_DATE
BEFORE INSERT OR UPDATE
ON SESSIONETS
FOR EACH ROW
BEGIN
    IF :NEW.DATE_FIN - :NEW.DATE_DEBUT < 70 THEN
        RAISE_APPLICATION_ERROR(-20001, 'La session doit durer au moins 10 semaines.');
    END IF;
END;
/

-- Question 2:
-- S'assurer que la date d'abandon ne depasse pas la date de debut de session par 20 jours

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_ABANDON
BEFORE INSERT OR UPDATE
ON INSCRIPTION
FOR EACH ROW
DECLARE
    DATE_INSCRIPTION DATE;
BEGIN
    SELECT S.DATE_DEBUT
    INTO DATE_INSCRIPTION
    FROM SESSIONETS S
    WHERE S.CODE_SESSION = :NEW.CODE_SESSION;
    IF :NEW.DATE_ABANDON - DATE_INSCRIPTION > 20 THEN
        RAISE_APPLICATION_ERROR(-20002, 'L''abandon de ce cours est impossible vu que cela fait plus que 20 jours que le cours a commence');
    END IF;
END;
/

-- Question 3:
-- S'assurer que les prealables aient ete reussi avant de permettre l'inscription

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_INSCRIPTION
BEFORE INSERT
ON INSCRIPTION
FOR EACH ROW
DECLARE
    TYPE LISTE_PREALABLE IS VARRAY(10) OF VARCHAR(7);
    PREALABLES LISTE_PREALABLE;
    COURS_TROUVE NUMBER;
    NOTE_COURS NUMBER;
BEGIN
    SELECT SIGLE_PREALABLE BULK COLLECT INTO PREALABLES FROM PREALABLE WHERE SIGLE = :NEW.SIGLE;
        FOR I IN 1..PREALABLES.COUNT LOOP
            SELECT COUNT(*) INTO COURS_TROUVE FROM INSCRIPTION WHERE CODE_PERMANENT = :NEW.CODE_PERMANENT AND SIGLE = PREALABLES(I);
            IF COURS_TROUVE = 1 THEN
                SELECT NVL(NOTE, 0) INTO NOTE_COURS FROM INSCRIPTION WHERE CODE_PERMANENT = :NEW.CODE_PERMANENT AND SIGLE = PREALABLES(I);
                IF NOTE_COURS < 60 THEN
                    RAISE_APPLICATION_ERROR(-20003, 'Les prerequis pour ce cours n''a pas ete atteint');
                END IF;
            ELSE
                RAISE_APPLICATION_ERROR(-20003, 'Les prerequis pour ce cours n''a pas ete atteint');
            END IF;
        END LOOP;
END;

-- Question 4:
-- Determiner le nombre de credits reussis

CREATE OR REPLACE FUNCTION FUNC_NOMBRE_CREDITS (CODE_P ETUDIANT.CODE_PERMANENT%TYPE)
RETURN COURS.NB_CREDITS%TYPE IS
    ANS COURS.NB_CREDITS%TYPE DEFAULT 0;
    TYPE LISTE_COURS IS TABLE OF VARCHAR(7);
    COURS_REUSSI LISTE_COURS := LISTE_COURS();
    NB_CREDIT NUMBER;
    ETUDIANT_TROUVE NUMBER;
    NONEXISTENT EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO ETUDIANT_TROUVE FROM ETUDIANT WHERE CODE_PERMANENT = CODE_P;
    IF ETUDIANT_TROUVE = 0 THEN
        RAISE NONEXISTENT;
    END IF;
    FOR COURS IN (SELECT * FROM INSCRIPTION WHERE CODE_P = INSCRIPTION.CODE_PERMANENT) LOOP
        IF (COURS_REUSSI.COUNT = 0) OR (COURS.SIGLE NOT MEMBER OF COURS_REUSSI AND COURS.NOTE >= 60) THEN
            COURS_REUSSI.EXTEND;
            COURS_REUSSI(NVL(COURS_REUSSI.LAST, 0)) := COURS.SIGLE;
            SELECT NVL(C.NB_CREDITS, 0) INTO NB_CREDIT FROM COURS C WHERE C.SIGLE=COURS.SIGLE;
            ANS := ANS + NB_CREDIT;
        END IF;
    END LOOP;
    RETURN ANS;
EXCEPTION
    WHEN NONEXISTENT THEN
        RAISE_APPLICATION_ERROR(-20004, 'L''etudiant n''existe pas');
END;
/

-- Cas test:
DECLARE
    C NUMBER;
BEGIN
    C := FUNC_NOMBRE_CREDITS('VSNV05127201');
    DBMS_OUTPUT.PUT_LINE('NOMBRE DE CREDITS REUSSIS: ' || C);
END;

-- Question 5:
-- Taux de reussite d'un cours pour un prof donne

CREATE OR REPLACE FUNCTION FUNC_TAUX_REUSSITE (CODE_P PROFESSEUR.CODE_PROFESSEUR%TYPE, S COURS.SIGLE%TYPE)
RETURN FLOAT IS
    ANS FLOAT;
    NONEXIST_PROF EXCEPTION;
    NONEXIST_COURS EXCEPTION;
    DIVISION_BY_ZERO EXCEPTION;
    TEST_COUNT SMALLINT;
    PASSE INT DEFAULT 0;
    TOTAL INT DEFAULT 0;
BEGIN
    SELECT COUNT(*) INTO TEST_COUNT FROM PROFESSEUR WHERE CODE_P = PROFESSEUR.CODE_PROFESSEUR;
    IF TEST_COUNT = 0 THEN
        RAISE NONEXIST_PROF;
    END IF;
    SELECT COUNT(*) INTO TEST_COUNT FROM COURS WHERE S = COURS.SIGLE;
    IF TEST_COUNT = 0 THEN
        RAISE NONEXIST_COURS;
    END IF;
    FOR P IN (SELECT * FROM INSCRIPTION I LEFT JOIN GROUPECOURS G on G.SIGLE = I.SIGLE and G.NO_GROUPE = I.NO_GROUPE and G.CODE_SESSION = I.CODE_SESSION WHERE G.CODE_PROFESSEUR = CODE_P AND I.SIGLE = S) LOOP
        IF P.NOTE IS NOT NULL THEN
            TOTAL := TOTAL + 1;
            IF P.NOTE >= 60 THEN
                PASSE := PASSE + 1;
            END IF;
        END IF;
    END LOOP;
    IF TOTAL = 0 THEN
        RAISE DIVISION_BY_ZERO;
    END IF;
    ANS := PASSE / TOTAL * 100;
    RETURN ANS;
EXCEPTION
    WHEN NONEXIST_PROF THEN
        RAISE_APPLICATION_ERROR(-20005, 'Le professeur n''existe pas');
    WHEN NONEXIST_COURS THEN
        RAISE_APPLICATION_ERROR(-20006, 'Ce sigle de cours n''existe pas');
    WHEN DIVISION_BY_ZERO THEN
        RAISE_APPLICATION_ERROR(-20007, 'Ce cours n''a pas encore eu d''etudiants');
END;
/

-- Cas test:
DECLARE
    C FLOAT;
BEGIN
    C := FUNC_TAUX_REUSSITE('DEVL2','INF3180');
    DBMS_OUTPUT.PUT_LINE('TAUX DE REUSSITE: ' || C || '%');
END;

-- Question 6:
-- Procedure affichant les differentes possibilites de la question 5

CREATE OR REPLACE PROCEDURE PROC_TAUX_REUSSITES AS
    NOM_COURS VARCHAR2(100);
    NOM_PROF VARCHAR2(100);
    PRENOM_PROF VARCHAR2(100);
BEGIN
    FOR R IN (SELECT SIGLE, CODE_PROFESSEUR FROM GROUPECOURS GROUP BY SIGLE, CODE_PROFESSEUR) LOOP
        BEGIN
            SELECT TITRE INTO NOM_COURS FROM COURS WHERE SIGLE = R.SIGLE;
            SELECT NOM, PRENOM INTO NOM_PROF, PRENOM_PROF FROM PROFESSEUR WHERE R.CODE_PROFESSEUR = PROFESSEUR.CODE_PROFESSEUR;
            DBMS_OUTPUT.PUT_LINE('TAUX DE REUSSITE POUR LE COURS ' || R.SIGLE || ' (' || NOM_COURS || ') AVEC LE PROFESSEUR ' || PRENOM_PROF || ' ' || NOM_PROF || ': ' || FUNC_TAUX_REUSSITE(R.CODE_PROFESSEUR, R.SIGLE) || '%');
        EXCEPTION
            WHEN OTHERS THEN
                CONTINUE;
        END;
    END LOOP;
END;
/

BEGIN
    PROC_TAUX_REUSSITES();
END;

-- Question 7:
-- Procedure pour determiner le statut d'un etudiant
