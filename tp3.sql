ALTER SESSION SET NLS_DATE_FORMAT = 'DD/MM/YYYY';

-- Question 1:
-- S'assurer que la date de fin de session est d'au moins 10 semaines

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_DATE
BEFORE INSERT OR UPDATE
ON SESSIONETS
FOR EACH ROW
BEGIN
    IF :NEW.DATE_FIN - :NEW.DATE_DEBUT < 70 THEN
        RAISE_APPLICATION_ERROR(-20001, 'La session doit durer au moins 10 semaines.');
    END IF;
END;
/

-- Question 2:
-- S'assurer que la date d'abandon ne depasse pas la date de debut de session par 20 jours

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_ABANDON
BEFORE INSERT OR UPDATE
ON INSCRIPTION
FOR EACH ROW
DECLARE
    DATE_INSCRIPTION DATE;
BEGIN
    SELECT S.DATE_DEBUT
    INTO DATE_INSCRIPTION
    FROM SESSIONETS S
    WHERE S.CODE_SESSION = :NEW.CODE_SESSION;
    IF :NEW.DATE_ABANDON - DATE_INSCRIPTION > 20 THEN
        RAISE_APPLICATION_ERROR(-20002, 'L''abandon de ce cours est impossible vu que cela fait plus que 20 jours que le cours a commence');
    END IF;
END;
/

-- Question 3:
-- S'assurer que les prealables aient ete reussi avant de permettre l'inscription

CREATE OR REPLACE TRIGGER TRG_VERIFICATION_INSCRIPTION
BEFORE INSERT
ON INSCRIPTION
FOR EACH ROW
DECLARE
    TYPE LISTE_PREALABLE IS VARRAY(10) OF VARCHAR(7);
    PREALABLES LISTE_PREALABLE;
    COURS_TROUVE NUMBER;
    NOTE_COURS NUMBER;
BEGIN
    SELECT SIGLE_PREALABLE BULK COLLECT INTO PREALABLES FROM PREALABLE WHERE SIGLE = :NEW.SIGLE;
        FOR I IN 1..PREALABLES.COUNT LOOP
            SELECT COUNT(*) INTO COURS_TROUVE FROM INSCRIPTION WHERE CODE_PERMANENT = :NEW.CODE_PERMANENT AND SIGLE = PREALABLES(I);
            IF COURS_TROUVE = 1 THEN
                SELECT NVL(NOTE, 0) INTO NOTE_COURS FROM INSCRIPTION WHERE CODE_PERMANENT = :NEW.CODE_PERMANENT AND SIGLE = PREALABLES(I);
                IF NOTE_COURS < 60 THEN
                    RAISE_APPLICATION_ERROR(-20003, 'Les prerequis pour ce cours n''a pas ete atteint');
                END IF;
            ELSE
                RAISE_APPLICATION_ERROR(-20003, 'Les prerequis pour ce cours n''a pas ete atteint');
            END IF;
        END LOOP;
END;

-- Question 4:
-- Determiner le nombre de credits reussis

CREATE OR REPLACE FUNCTION FUNC_NOMBRE_CREDITS (CODE_P ETUDIANT.CODE_PERMANENT%TYPE)
RETURN COURS.NB_CREDITS%TYPE IS
    ANS COURS.NB_CREDITS%TYPE DEFAULT 0;
    TYPE LISTE_COURS IS TABLE OF VARCHAR(7);
    COURS_REUSSI LISTE_COURS := LISTE_COURS();
    NB_CREDIT NUMBER;
    ETUDIANT_TROUVE NUMBER;
    NONEXISTENT EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO ETUDIANT_TROUVE FROM ETUDIANT WHERE CODE_PERMANENT = CODE_P;
    IF ETUDIANT_TROUVE = 0 THEN
        RAISE NONEXISTENT;
    END IF;
    FOR COURS IN (SELECT * FROM INSCRIPTION WHERE CODE_P = INSCRIPTION.CODE_PERMANENT) LOOP
        IF (COURS_REUSSI.COUNT = 0) OR (COURS.SIGLE NOT MEMBER OF COURS_REUSSI AND COURS.NOTE >= 60) THEN
            COURS_REUSSI.EXTEND;
            COURS_REUSSI(NVL(COURS_REUSSI.LAST, 0)) := COURS.SIGLE;
            SELECT NVL(C.NB_CREDITS, 0) INTO NB_CREDIT FROM COURS C WHERE C.SIGLE=COURS.SIGLE;
            ANS := ANS + NB_CREDIT;
        END IF;
    END LOOP;
    RETURN ANS;
EXCEPTION
    WHEN NONEXISTENT THEN
        RAISE_APPLICATION_ERROR(-20004, 'L''etudiant n''existe pas');
        return null; -- silence compiler error
END;
/

-- Cas test:
DECLARE
    C NUMBER;
BEGIN
    C := FUNC_NOMBRE_CREDITS('VSNV05127201');
    DBMS_OUTPUT.PUT_LINE('NOMBRE DE CREDITS REUSSIS: ' || C);
END;

-- Question 5:
-- Taux de reussite d'un cours pour un prof donne

CREATE OR REPLACE FUNCTION FUNC_TAUX_REUSSITE (CODE_P PROFESSEUR.CODE_PROFESSEUR%TYPE, S COURS.SIGLE%TYPE)
RETURN FLOAT IS
    ANS FLOAT;
    NONEXIST_PROF EXCEPTION;
    NONEXIST_COURS EXCEPTION;
    DIVISION_BY_ZERO EXCEPTION;
    TEST_COUNT SMALLINT;
    PASSE INT DEFAULT 0;
    TOTAL INT DEFAULT 0;
BEGIN
    SELECT COUNT(*) INTO TEST_COUNT FROM PROFESSEUR WHERE CODE_P = PROFESSEUR.CODE_PROFESSEUR;
    IF TEST_COUNT = 0 THEN
        RAISE NONEXIST_PROF;
    END IF;
    SELECT COUNT(*) INTO TEST_COUNT FROM COURS WHERE S = COURS.SIGLE;
    IF TEST_COUNT = 0 THEN
        RAISE NONEXIST_COURS;
    END IF;
    FOR P IN (SELECT * FROM INSCRIPTION I LEFT JOIN GROUPECOURS G on G.SIGLE = I.SIGLE and G.NO_GROUPE = I.NO_GROUPE and G.CODE_SESSION = I.CODE_SESSION WHERE G.CODE_PROFESSEUR = CODE_P AND I.SIGLE = S) LOOP
        IF P.NOTE IS NOT NULL THEN
            TOTAL := TOTAL + 1;
            IF P.NOTE >= 60 THEN
                PASSE := PASSE + 1;
            END IF;
        END IF;
    END LOOP;
    IF TOTAL = 0 THEN
        RAISE DIVISION_BY_ZERO;
    END IF;
    ANS := PASSE / TOTAL * 100;
    RETURN ANS;
EXCEPTION
    WHEN NONEXIST_PROF THEN
        RAISE_APPLICATION_ERROR(-20005, 'Le professeur n''existe pas');
        return null; -- silence compiler error
    WHEN NONEXIST_COURS THEN
        RAISE_APPLICATION_ERROR(-20006, 'Ce sigle de cours n''existe pas');
        return null; -- silence compiler error
    WHEN DIVISION_BY_ZERO THEN
        RAISE_APPLICATION_ERROR(-20007, 'Ce cours n''a pas encore eu d''etudiants');
        return null; -- silence compiler error
END;
/

-- Cas test:
DECLARE
    C FLOAT;
BEGIN
    C := FUNC_TAUX_REUSSITE('DEVL2','INF3180');
    DBMS_OUTPUT.PUT_LINE('TAUX DE REUSSITE: ' || C || '%');
END;

-- Question 6:
-- Procedure affichant les differentes possibilites de la question 5

CREATE OR REPLACE PROCEDURE PROC_TAUX_REUSSITES AS
    NOM_COURS VARCHAR2(100);
    NOM_PROF VARCHAR2(100);
    PRENOM_PROF VARCHAR2(100);
BEGIN
    FOR R IN (SELECT SIGLE, CODE_PROFESSEUR FROM GROUPECOURS GROUP BY SIGLE, CODE_PROFESSEUR) LOOP
        BEGIN
            SELECT TITRE INTO NOM_COURS FROM COURS WHERE SIGLE = R.SIGLE;
            SELECT NOM, PRENOM INTO NOM_PROF, PRENOM_PROF FROM PROFESSEUR WHERE R.CODE_PROFESSEUR = PROFESSEUR.CODE_PROFESSEUR;
            DBMS_OUTPUT.PUT_LINE('TAUX DE REUSSITE POUR LE COURS ' || R.SIGLE || ' (' || NOM_COURS || ') AVEC LE PROFESSEUR ' || PRENOM_PROF || ' ' || NOM_PROF || ': ' || FUNC_TAUX_REUSSITE(R.CODE_PROFESSEUR, R.SIGLE) || '%');
        EXCEPTION
            WHEN OTHERS THEN
                CONTINUE;
        END;
    END LOOP;
END;
/

BEGIN
    PROC_TAUX_REUSSITES();
END;

-- Question 7:
-- Procedure pour determiner le statut d'un etudiant

CREATE OR REPLACE PROCEDURE PROC_STATUT_ETUDIANT(MAT ETUDIANT.CODE_PERMANENT%TYPE, SES SESSIONETS.CODE_SESSION%TYPE) AS
    NB_COURS SMALLINT DEFAULT 0;
    NB_CREDIT SMALLINT DEFAULT 0;
    TROUVE SMALLINT;
    NONEXIST_ELEVE EXCEPTION;
    NONEXIST_SES EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO TROUVE FROM ETUDIANT WHERE CODE_PERMANENT = MAT;
    IF TROUVE = 0 THEN
        RAISE NONEXIST_ELEVE;
    END IF;
    SELECT COUNT(*) INTO TROUVE FROM SESSIONETS WHERE CODE_SESSION = SES;
    IF TROUVE = 0 THEN
        RAISE NONEXIST_SES;
    END IF;
    FOR R IN (SELECT C2.NB_CREDITS FROM INSCRIPTION I LEFT OUTER JOIN COURS C2 on I.SIGLE = C2.SIGLE WHERE I.CODE_PERMANENT = MAT AND SES = I.CODE_SESSION AND I.DATE_ABANDON IS NULL) LOOP
        NB_COURS := NB_COURS + 1;
        NB_CREDIT := NB_CREDIT + R.NB_CREDITS;
    END LOOP;
    IF NB_CREDIT >= 12 THEN
        DBMS_OUTPUT.PUT_LINE('ETUDE-PLEIN-TEMPS');
    ELSIF NB_CREDIT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('ETUDE-TEMPS-PARTIEL');
    ELSE
        DBMS_OUTPUT.PUT_LINE('NON-INSCRIT');
    END IF;
    DBMS_OUTPUT.PUT_LINE('NOMBRE DE COURS:' || NB_COURS);
    DBMS_OUTPUT.PUT_LINE('NOMBRE DE CREDITS:' || NB_CREDIT);
EXCEPTION
    WHEN NONEXIST_ELEVE THEN
        RAISE_APPLICATION_ERROR(-20004, 'L''etudiant n''existe pas');
    WHEN NONEXIST_SES THEN
        RAISE_APPLICATION_ERROR(-20008, 'Ce code de session n''existe pas');
END;
/

-- Cas test:
BEGIN
    PROC_STATUT_ETUDIANT('TREJ18088001', 32003);
END;

-- Question 8:
-- Ajouter des cotes au tableau inscription

ALTER TABLE INSCRIPTION
ADD COTE VARCHAR2(1) CHECK(COTE IN ('A', 'B', 'C', 'D', 'E', NULL));

CREATE OR REPLACE FUNCTION FUNC_CONVERT_NOTE_TO_COTE (N INSCRIPTION.NOTE%TYPE)
RETURN VARCHAR2 IS
    C VARCHAR2(1);
    TOO_BIG EXCEPTION;
    TOO_SMALL EXCEPTION;
BEGIN
    IF (N IS NULL) THEN
        C := NULL;
    ELSIF (N > 100) THEN
        RAISE TOO_BIG;
    ELSIF (N >= 90) THEN
        C := 'A';
    ELSIF (N >= 80) THEN
        C := 'B';
    ELSIF (N >= 70) THEN
        C := 'C';
    ELSIF (N >= 60) THEN
        C := 'D';
    ELSIF (N >= 0) THEN
        C := 'E';
    ELSE
        RAISE TOO_SMALL;
    END IF;
    RETURN C;
EXCEPTION
    WHEN TOO_SMALL THEN
        RAISE_APPLICATION_ERROR(-20009, 'La note ne peut etre en dessous de 0');
        return null; -- silence compiler error
    WHEN TOO_BIG THEN
        RAISE_APPLICATION_ERROR(-20010, 'La note ne peut etre au dessus de 100');
        return null; -- silence compiler error
END;
/

BEGIN
    FOR R IN (SELECT * FROM INSCRIPTION) LOOP
        UPDATE INSCRIPTION I SET I.COTE = FUNC_CONVERT_NOTE_TO_COTE(R.NOTE) WHERE I.SIGLE = R.SIGLE AND R.CODE_SESSION = I.CODE_SESSION AND R.CODE_PERMANENT = I.CODE_PERMANENT AND R.NO_GROUPE = I.NO_GROUPE;
    END LOOP;
END;

-- Question 9:
-- Procedure pour creer le bulletin

CREATE OR REPLACE PROCEDURE PROC_BULLETIN(MAT ETUDIANT.CODE_PERMANENT%TYPE) AS
    NONEXIST_ELEVE EXCEPTION;
    TROUVE SMALLINT;
    FN VARCHAR2(20);
    LN VARCHAR2(20);
BEGIN
    SELECT COUNT(*) INTO TROUVE FROM ETUDIANT WHERE CODE_PERMANENT = MAT;
    IF TROUVE = 0 THEN
        RAISE NONEXIST_ELEVE;
    END IF;
    SELECT PRENOM, NOM INTO FN, LN FROM ETUDIANT WHERE CODE_PERMANENT = MAT;
    DBMS_OUTPUT.PUT_LINE('CODE PERMANENT: ' || MAT);
    DBMS_OUTPUT.PUT_LINE('NOM: ' || LN);
    DBMS_OUTPUT.PUT_LINE('PRENOM: ' || FN);
    DBMS_OUTPUT.PUT_LINE(RPAD('SIGLE', 10)||RPAD('NOGROUPE', 10)||RPAD('SESSION', 10)||RPAD('NOTE', 5)||RPAD('COTE', 5));
    FOR R IN (SELECT * FROM INSCRIPTION WHERE CODE_PERMANENT = MAT) LOOP
        DBMS_OUTPUT.PUT_LINE(RPAD(R.SIGLE, 10)||RPAD(R.NO_GROUPE, 10)||RPAD(R.CODE_SESSION, 10)||RPAD(R.NOTE, 5)||RPAD(R.COTE, 5));
    END LOOP;
EXCEPTION
    WHEN NONEXIST_ELEVE THEN
        RAISE_APPLICATION_ERROR(-20004, 'L''etudiant n''existe pas');
END;
/

BEGIN
    PROC_BULLETIN('TREJ18088001');
END;